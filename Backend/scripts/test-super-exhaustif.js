const { ethers } = require("hardhat");

async function main() {
    console.log("üî¨ TEST SUPER EXHAUSTIF - TOUS LES SC√âNARIOS POSSIBLES");
    console.log("=" .repeat(80));
    console.log("üìã ON TESTE VRAIMENT TOUT - MULTI-ROUNDS, GOUVERNANCE, FRAIS, ERREURS");
    console.log("=" .repeat(80));
    
    let results = {
        deployments: { success: 0, failed: 0, details: [] },
        rounds: { success: 0, failed: 0, details: [] },
        refunds: { success: 0, failed: 0, details: [] },
        governance: { success: 0, failed: 0, details: [] },
        dao: { success: 0, failed: 0, details: [] },
        costs: { deploymentCosts: [], transactionCosts: [] },
        bugs: [],
        warnings: []
    };

    try {
        // R√©cup√©rer plus de signers pour tests avanc√©s
        let [deployer, founder, investor1, investor2, investor3, investor4, treasury, keeper] = await ethers.getSigners();
        
        console.log("\nüë• PARTICIPANTS (8 ADDRESSES):");
        console.log("üèóÔ∏è Deployeur:", deployer.address);
        console.log("üëë Founder:", founder.address);
        console.log("üí∞ Investor1:", investor1.address);
        console.log("üí∞ Investor2:", investor2.address);
        console.log("üí∞ Investor3:", investor3.address);
        console.log("üí∞ Investor4:", investor4.address);
        console.log("üè¶ Treasury:", treasury.address);
        console.log("ü§ñ Keeper:", keeper.address);

        // ===== PHASE 1: D√âPLOIEMENTS AVEC CO√õTS =====
        console.log("\n" + "=".repeat(60));
        console.log("üèóÔ∏è PHASE 1 - D√âPLOIEMENTS ET CO√õTS");
        console.log("=".repeat(60));

        let campaign, dao, governance, liveManager;
        
        // D√©ploiement Campaign avec co√ªts
        try {
            const deployerBalanceBefore = await ethers.provider.getBalance(deployer.address);
            
            const Campaign = await ethers.getContractFactory("Campaign");
            const deployTx = await Campaign.getDeployTransaction(
                founder.address,
                "Test Super Exhaustif",
                "TSE",
                ethers.utils.parseEther("50"), // 50 ETH target (gros projet)
                ethers.utils.parseEther("2.5"), // 2.5 ETH par NFT
                Math.floor(Date.now() / 1000) + (30 * 24 * 60 * 60), // 30 jours
                treasury.address,
                750, // 7.5% commission
                treasury.address,
                "ipfs://super-exhaustif-test",
                deployer.address,
                keeper.address
            );
            
            const gasEstimate = await ethers.provider.estimateGas(deployTx);
            campaign = await Campaign.deploy(
                founder.address, "Test Super Exhaustif", "TSE",
                ethers.utils.parseEther("50"), ethers.utils.parseEther("2.5"),
                Math.floor(Date.now() / 1000) + (30 * 24 * 60 * 60),
                treasury.address, 750, treasury.address, "ipfs://super-exhaustif-test",
                deployer.address, keeper.address
            );
            
            const receipt = await campaign.deployTransaction.wait();
            const deployerBalanceAfter = await ethers.provider.getBalance(deployer.address);
            const deploymentCost = deployerBalanceBefore.sub(deployerBalanceAfter);
            
            console.log("‚úÖ Campaign d√©ploy√©:", campaign.address);
            console.log(`üí∞ Co√ªt d√©ploiement: ${ethers.utils.formatEther(deploymentCost)} ETH`);
            console.log(`‚õΩ Gas utilis√©: ${receipt.gasUsed.toString()}`);
            
            results.deployments.success++;
            results.costs.deploymentCosts.push({
                contract: "Campaign",
                cost: ethers.utils.formatEther(deploymentCost),
                gasUsed: receipt.gasUsed.toString()
            });
            
        } catch (error) {
            console.log("‚ùå Campaign d√©ploiement FAILED:", error.message.split('\n')[0]);
            results.deployments.failed++;
            results.deployments.details.push({ contract: "Campaign", status: "FAILED", error: error.message });
        }

        // D√©ploiement LiveSessionManager
        try {
            const LiveSessionManager = await ethers.getContractFactory("LiveSessionManager");
            liveManager = await LiveSessionManager.deploy();
            const receipt = await liveManager.deployTransaction.wait();
            
            console.log("‚úÖ LiveSessionManager d√©ploy√©:", liveManager.address);
            console.log(`‚õΩ Gas utilis√©: ${receipt.gasUsed.toString()}`);
            results.deployments.success++;
            
        } catch (error) {
            console.log("‚ùå LiveSessionManager FAILED:", error.message.split('\n')[0]);
            results.deployments.failed++;
        }

        // D√©ploiement CampaignDAO (qui paye ?)
        try {
            const founderBalanceBefore = await ethers.provider.getBalance(founder.address);
            
            const CampaignDAO = await ethers.getContractFactory("CampaignDAO", founder); // Founder d√©ploie
            dao = await CampaignDAO.deploy(campaign.address, liveManager.address, founder.address);
            const receipt = await dao.deployTransaction.wait();
            
            const founderBalanceAfter = await ethers.provider.getBalance(founder.address);
            const daoCost = founderBalanceBefore.sub(founderBalanceAfter);
            
            console.log("‚úÖ CampaignDAO d√©ploy√© par FOUNDER:", dao.address);
            console.log(`üí∞ Co√ªt DAO pour founder: ${ethers.utils.formatEther(daoCost)} ETH`);
            console.log(`‚õΩ Gas utilis√©: ${receipt.gasUsed.toString()}`);
            
            results.deployments.success++;
            results.costs.deploymentCosts.push({
                contract: "CampaignDAO",
                payer: "FOUNDER",
                cost: ethers.utils.formatEther(daoCost),
                gasUsed: receipt.gasUsed.toString()
            });
            
        } catch (error) {
            console.log("‚ùå CampaignDAO FAILED:", error.message.split('\n')[0]);
            results.deployments.failed++;
        }

        // D√©ploiement CampaignGovernance (qui paye ?)
        try {
            const deployerBalanceBefore = await ethers.provider.getBalance(deployer.address);
            
            const CampaignGovernance = await ethers.getContractFactory("CampaignGovernance", deployer); // Deployer paye
            governance = await CampaignGovernance.deploy(campaign.address, founder.address);
            const receipt = await governance.deployTransaction.wait();
            
            const deployerBalanceAfter = await ethers.provider.getBalance(deployer.address);
            const govCost = deployerBalanceBefore.sub(deployerBalanceAfter);
            
            console.log("‚úÖ CampaignGovernance d√©ploy√© par DEPLOYER:", governance.address);
            console.log(`üí∞ Co√ªt Governance pour deployer: ${ethers.utils.formatEther(govCost)} ETH`);
            console.log(`‚õΩ Gas utilis√©: ${receipt.gasUsed.toString()}`);
            
            results.deployments.success++;
            results.costs.deploymentCosts.push({
                contract: "CampaignGovernance", 
                payer: "DEPLOYER",
                cost: ethers.utils.formatEther(govCost),
                gasUsed: receipt.gasUsed.toString()
            });
            
        } catch (error) {
            console.log("‚ùå CampaignGovernance FAILED:", error.message.split('\n')[0]);
            results.deployments.failed++;
        }

        // Connexions
        await campaign.connect(founder).setDAOContract(dao.address);
        await campaign.connect(founder).setGovernanceContract(governance.address);
        console.log("‚úÖ Tous les contrats connect√©s");

        // ===== PHASE 2: ROUND 1 EXHAUSTIF =====
        console.log("\n" + "=".repeat(60));
        console.log("üí∞ PHASE 2 - ROUND 1 EXHAUSTIF (50 ETH TARGET)");
        console.log("=".repeat(60));

        // Investissement 1: Petit investisseur
        try {
            const tx = await campaign.connect(investor1).buyShares(2, { value: ethers.utils.parseEther("5") });
            const receipt = await tx.wait();
            console.log(`‚úÖ Investor1: 2 NFTs pour 5 ETH (gas: ${receipt.gasUsed})`);
            results.rounds.success++;
            
            const balance1 = await campaign.balanceOf(investor1.address);
            console.log(`üìä Balance Investor1: ${balance1} NFTs`);
            
        } catch (error) {
            console.log("‚ùå Investor1 Round1 FAILED:", error.message.split('\n')[0]);
            results.rounds.failed++;
        }

        // Investissement 2: Gros investisseur
        try {
            await campaign.connect(investor2).buyShares(8, { value: ethers.utils.parseEther("20") });
            console.log("‚úÖ Investor2: 8 NFTs pour 20 ETH (gros investisseur)");
            results.rounds.success++;
            
        } catch (error) {
            console.log("‚ùå Investor2 Round1 FAILED:", error.message.split('\n')[0]);
            results.rounds.failed++;
        }

        // Investissement 3: Compl√©ter pour atteindre objectif
        try {
            await campaign.connect(investor3).buyShares(10, { value: ethers.utils.parseEther("25") });
            console.log("‚úÖ Investor3: 10 NFTs pour 25 ETH (atteint objectif)");
            results.rounds.success++;
            
            // V√©rifier auto-finalisation
            const roundInfo = await campaign.getCurrentRound();
            console.log(`üìä Round 1: ${ethers.utils.formatEther(roundInfo.fundsRaised)} ETH, finalis√©: ${roundInfo.isFinalized}`);
            
            if (roundInfo.isFinalized) {
                console.log("‚úÖ AUTO-FINALISATION Round 1 OK");
                results.rounds.success++;
            } else {
                console.log("‚ö†Ô∏è Round 1 pas auto-finalis√©");
                results.warnings.push("Round 1 devrait √™tre auto-finalis√©");
            }
            
        } catch (error) {
            console.log("‚ùå Investor3 Round1 FAILED:", error.message.split('\n')[0]);
            results.rounds.failed++;
        }

        // ===== PHASE 3: TESTS REMBOURSEMENT ROUND 1 =====
        console.log("\n" + "=".repeat(60));
        console.log("üîÑ PHASE 3 - TESTS REMBOURSEMENT ROUND 1");
        console.log("=".repeat(60));

        // Test 1: Remboursement apr√®s finalisation (avant live)
        console.log("\nüß™ TEST 1: Remboursement Round 1 apr√®s finalisation (avant live)");
        try {
            const [canRefund1, msg1] = await campaign.canRefundToken(1000001);
            console.log(`NFT #1000001: ${canRefund1 ? '‚úÖ' : '‚ùå'} - ${msg1}`);
            
            if (!canRefund1 && msg1.includes("not active")) {
                results.refunds.success++;
                console.log("‚úÖ CORRECT: NFT bloqu√© apr√®s finalisation");
            } else {
                results.bugs.push("NFT Round 1 remboursable apr√®s finalisation (avant live)");
                results.refunds.failed++;
            }
            
        } catch (error) {
            console.log("‚ùå Test remboursement 1 FAILED:", error.message.split('\n')[0]);
            results.refunds.failed++;
        }

        // ===== PHASE 4: ROUND 2 =====
        console.log("\n" + "=".repeat(60));
        console.log("üöÄ PHASE 4 - ROUND 2 (PRIX AUGMENT√â)");
        console.log("=".repeat(60));

        try {
            await campaign.connect(founder).startNewRound(
                ethers.utils.parseEther("80"), // 80 ETH target
                ethers.utils.parseEther("4"),   // 4 ETH par NFT (+60%)
                30 * 24 * 60 * 60 // 30 jours
            );
            console.log("‚úÖ Round 2 d√©marr√©: 4 ETH/NFT (60% augmentation)");
            results.rounds.success++;
            
            // Investissement Round 2
            await campaign.connect(investor4).buyShares(3, { value: ethers.utils.parseEther("12") });
            console.log("‚úÖ Investor4: 3 NFTs Round 2 pour 12 ETH");
            results.rounds.success++;
            
            // V√©rifier IDs des NFTs Round 2
            const balance4 = await campaign.balanceOf(investor4.address);
            const tokenId = await campaign.tokenOfOwnerByIndex(investor4.address, 0);
            console.log(`üìä Investor4 balance: ${balance4}, premier NFT ID: ${tokenId}`);
            
            if (tokenId.toString().startsWith("2000")) {
                console.log("‚úÖ NFT IDs Round 2 corrects (2000xxx)");
                results.rounds.success++;
            } else {
                results.bugs.push("NFT IDs Round 2 incorrects");
                results.rounds.failed++;
            }
            
        } catch (error) {
            console.log("‚ùå Round 2 FAILED:", error.message.split('\n')[0]);
            results.rounds.failed++;
        }

        // ===== PHASE 5: TESTS REMBOURSEMENT MULTI-ROUNDS =====
        console.log("\n" + "=".repeat(60));
        console.log("üîÑ PHASE 5 - REMBOURSEMENTS MULTI-ROUNDS");
        console.log("=".repeat(60));

        // Test 2: Round 1 pendant Round 2 actif (CRITIQUE)
        console.log("\nüß™ TEST 2 (CRITIQUE): Round 1 pendant Round 2 actif");
        try {
            const [canRefund2, msg2] = await campaign.canRefundToken(1000001);
            console.log(`NFT #1000001 (R1): ${canRefund2 ? 'üö®' : '‚úÖ'} - ${msg2}`);
            
            if (canRefund2) {
                results.bugs.push("BUG CRITIQUE: NFT Round 1 remboursable pendant Round 2");
                console.log("üö® BUG D√âTECT√â: NFT Round 1 ne devrait PAS √™tre remboursable pendant Round 2!");
            } else {
                results.refunds.success++;
                console.log("‚úÖ CORRECT: NFT Round 1 bloqu√© pendant Round 2");
            }
            
        } catch (error) {
            console.log("‚ùå Test remboursement 2 FAILED:", error.message.split('\n')[0]);
            results.refunds.failed++;
        }

        // Test 3: Round 2 actuel
        console.log("\nüß™ TEST 3: Round 2 actuel remboursable");
        try {
            const [canRefund3, msg3] = await campaign.canRefundToken(2000001);
            console.log(`NFT #2000001 (R2): ${canRefund3 ? '‚úÖ' : '‚ùå'} - ${msg3}`);
            
            if (canRefund3) {
                results.refunds.success++;
                console.log("‚úÖ CORRECT: NFT Round 2 remboursable (round actif)");
            } else {
                results.bugs.push("NFT Round 2 pas remboursable alors que round actif");
                results.refunds.failed++;
            }
            
        } catch (error) {
            console.log("‚ùå Test remboursement 3 FAILED:", error.message.split('\n')[0]);
            results.refunds.failed++;
        }

        // ===== PHASE 6: SESSION LIVE AVEC ROUND 2 =====
        console.log("\n" + "=".repeat(60));
        console.log("üé¨ PHASE 6 - SESSION LIVE (ROUND 2 ACTIF)");
        console.log("=".repeat(60));

        // Finaliser Round 2 d'abord
        try {
            await campaign.connect(keeper).finalizeRound();
            console.log("‚úÖ Round 2 finalis√© par Keeper");
            results.dao.success++;
        } catch (error) {
            console.log("‚ùå Finalisation Round 2 FAILED:", error.message.split('\n')[0]);
            results.dao.failed++;
        }

        // V√©rifier phase DAO
        try {
            const daoPhase = await dao.getCurrentPhase();
            console.log(`üèõÔ∏è Phase DAO: ${daoPhase} (1=WAITING_FOR_LIVE)`);
            
            if (daoPhase == 1) {
                results.dao.success++;
                console.log("‚úÖ DAO en attente de programmation live");
            } else {
                results.bugs.push("DAO pas en phase WAITING_FOR_LIVE apr√®s finalisation");
                results.dao.failed++;
            }
        } catch (error) {
            console.log("‚ùå Phase DAO check FAILED:", error.message.split('\n')[0]);
        }

        // Programmer et faire session live compl√®te
        const futureTime = Math.floor(Date.now() / 1000) + 3600;
        await dao.connect(founder).scheduleLiveSession(futureTime, "https://live.test.com");
        
        await ethers.provider.send("evm_increaseTime", [3600]);
        await ethers.provider.send("evm_mine");
        
        await dao.connect(founder).startLiveSession();
        console.log("‚úÖ Live session d√©marr√©e");
        
        await ethers.provider.send("evm_increaseTime", [25 * 60]); // 25 min
        await ethers.provider.send("evm_mine");
        
        await dao.connect(founder).endLiveSession(20);
        console.log("‚úÖ Live session termin√©e (25 min - VALIDE)");
        
        const finalPhase = await dao.getCurrentPhase();
        if (finalPhase == 4) { // EXCHANGE_PERIOD
            console.log("‚úÖ DAO en phase EXCHANGE_PERIOD");
            results.dao.success++;
        } else {
            console.log("‚ùå DAO pas en phase EXCHANGE_PERIOD:", finalPhase);
            results.dao.failed++;
        }

        // ===== PHASE 7: REMBOURSEMENTS POST-LIVE =====
        console.log("\n" + "=".repeat(60));
        console.log("üîÑ PHASE 7 - REMBOURSEMENTS POST-LIVE (TOUS ROUNDS)");
        console.log("=".repeat(60));

        // Test 4: Round 1 pendant EXCHANGE_PERIOD
        console.log("\nüß™ TEST 4 (CRITIQUE): Round 1 pendant EXCHANGE_PERIOD");
        try {
            const [canRefund4, msg4] = await campaign.canRefundToken(1000001);
            console.log(`NFT #1000001 (R1): ${canRefund4 ? '‚úÖ' : '‚ùå'} - ${msg4}`);
            
            if (canRefund4) {
                results.refunds.success++;
                console.log("‚úÖ CRITIQUE VALID√â: NFT Round 1 remboursable pendant √©change");
                
                // Test remboursement r√©el Round 1
                const balanceBefore = await ethers.provider.getBalance(investor1.address);
                const refundAmount = await campaign.getRefundAmount(1000001);
                console.log(`üí∞ Montant remboursement pr√©vu: ${ethers.utils.formatEther(refundAmount)} ETH`);
                
                await campaign.connect(investor1).refundShares([1000001]);
                
                const balanceAfter = await ethers.provider.getBalance(investor1.address);
                const netGain = balanceAfter.sub(balanceBefore);
                console.log(`‚úÖ Remboursement Round 1 r√©ussi: ${ethers.utils.formatEther(netGain)} ETH net`);
                
            } else {
                results.bugs.push("CRITIQUE: NFT Round 1 pas remboursable pendant EXCHANGE_PERIOD");
                console.log("üö® BUG CRITIQUE: NFT Round 1 devrait √™tre remboursable!");
            }
            
        } catch (error) {
            console.log("‚ùå Test remboursement 4 FAILED:", error.message.split('\n')[0]);
            results.refunds.failed++;
        }

        // Test 5: Round 2 pendant EXCHANGE_PERIOD  
        console.log("\nüß™ TEST 5: Round 2 pendant EXCHANGE_PERIOD");
        try {
            const [canRefund5, msg5] = await campaign.canRefundToken(2000001);
            console.log(`NFT #2000001 (R2): ${canRefund5 ? '‚úÖ' : '‚ùå'} - ${msg5}`);
            
            if (canRefund5) {
                results.refunds.success++;
                console.log("‚úÖ NFT Round 2 aussi remboursable pendant √©change");
                
                // Test remboursement r√©el Round 2  
                const balanceBefore = await ethers.provider.getBalance(investor4.address);
                const refundAmount = await campaign.getRefundAmount(2000001);
                console.log(`üí∞ Montant remboursement Round 2 pr√©vu: ${ethers.utils.formatEther(refundAmount)} ETH`);
                
                await campaign.connect(investor4).refundShares([2000001]);
                
                const balanceAfter = await ethers.provider.getBalance(investor4.address);
                const netGain = balanceAfter.sub(balanceBefore);
                console.log(`‚úÖ Remboursement Round 2 r√©ussi: ${ethers.utils.formatEther(netGain)} ETH net`);
                
            } else {
                results.bugs.push("NFT Round 2 pas remboursable pendant EXCHANGE_PERIOD");
                results.refunds.failed++;
            }
            
        } catch (error) {
            console.log("‚ùå Test remboursement 5 FAILED:", error.message.split('\n')[0]);
            results.refunds.failed++;
        }

        // ===== PHASE 8: GOUVERNANCE EXHAUSTIVE =====
        console.log("\n" + "=".repeat(60));
        console.log("üó≥Ô∏è PHASE 8 - GOUVERNANCE EXHAUSTIVE");
        console.log("=".repeat(60));

        // V√©rifier pouvoirs de vote d√©taill√©s
        console.log("\nüìä POUVOIRS DE VOTE PAR INVESTISSEUR:");
        const power1 = await governance.getVotingPower(investor1.address);
        const power2 = await governance.getVotingPower(investor2.address); 
        const power3 = await governance.getVotingPower(investor3.address);
        const power4 = await governance.getVotingPower(investor4.address);
        
        console.log(`Investor1: ${power1} votes (2 NFTs R1 - 1 rembours√© = 1)`);
        console.log(`Investor2: ${power2} votes (8 NFTs R1)`);
        console.log(`Investor3: ${power3} votes (10 NFTs R1)`);
        console.log(`Investor4: ${power4} votes (3 NFTs R2 - 1 rembours√© = 2)`);
        
        const totalVotingPower = power1.add(power2).add(power3).add(power4);
        console.log(`üí™ Total pouvoir de vote: ${totalVotingPower}`);

        if (power1.gt(0) && power2.gt(0) && power3.gt(0) && power4.gt(0)) {
            results.governance.success++;
            console.log("‚úÖ Tous les investisseurs ont du pouvoir de vote");
        } else {
            results.bugs.push("Certains investisseurs n'ont pas de pouvoir de vote");
            results.governance.failed++;
        }

        // Cr√©ation de proposition par founder
        console.log("\nüèõÔ∏è CR√âATION DE PROPOSITION GOUVERNANCE:");
        try {
            const founderBalanceBefore = await ethers.provider.getBalance(founder.address);
            
            const tx = await governance.connect(founder).createProposal(
                0, // PARAMETER_CHANGE
                "R√©duire commission de 7.5% √† 5%",
                "R√©duction commission pour encourager plus d'investissements dans les rounds futurs. Cela b√©n√©ficiera √† tous les holders NFT.",
                ethers.utils.defaultAbiCoder.encode(["uint256"], [500]), // 5%
                20, // 20% quorum
                60  // 60% majorit√© requise
            );
            
            const receipt = await tx.wait();
            const founderBalanceAfter = await ethers.provider.getBalance(founder.address);
            const proposalCost = founderBalanceBefore.sub(founderBalanceAfter);
            
            console.log("‚úÖ Proposition cr√©√©e par FOUNDER");
            console.log(`üí∞ Co√ªt cr√©ation proposition: ${ethers.utils.formatEther(proposalCost)} ETH`);
            console.log(`‚õΩ Gas utilis√©: ${receipt.gasUsed}`);
            
            results.governance.success++;
            results.costs.transactionCosts.push({
                action: "CREATE_PROPOSAL",
                payer: "FOUNDER",
                cost: ethers.utils.formatEther(proposalCost),
                gasUsed: receipt.gasUsed.toString()
            });
            
        } catch (error) {
            console.log("‚ùå Cr√©ation proposition FAILED:", error.message.split('\n')[0]);
            results.governance.failed++;
        }

        // Votes d√©taill√©s avec co√ªts
        console.log("\nüó≥Ô∏è VOTES AVEC CO√õTS:");
        
        // Vote Investor2 (POUR)
        try {
            const voterBalanceBefore = await ethers.provider.getBalance(investor2.address);
            const tx = await governance.connect(investor2).castVote(1, 1, "Je vote POUR car r√©duire commission augmente valeur NFTs");
            const receipt = await tx.wait();
            const voterBalanceAfter = await ethers.provider.getBalance(investor2.address);
            const voteCost = voterBalanceBefore.sub(voterBalanceAfter);
            
            console.log("‚úÖ Investor2 vote POUR (8 votes)");
            console.log(`üí∞ Co√ªt vote: ${ethers.utils.formatEther(voteCost)} ETH`);
            results.governance.success++;
            
        } catch (error) {
            console.log("‚ùå Vote Investor2 FAILED:", error.message.split('\n')[0]);
            results.governance.failed++;
        }

        // Vote Investor3 (CONTRE)
        try {
            await governance.connect(investor3).castVote(1, 0, "Je vote CONTRE car commission actuelle finance bien le d√©veloppement");
            console.log("‚úÖ Investor3 vote CONTRE (10 votes)");
            results.governance.success++;
            
        } catch (error) {
            console.log("‚ùå Vote Investor3 FAILED:", error.message.split('\n')[0]);
            results.governance.failed++;
        }

        // Vote Investor4 (POUR)
        try {
            await governance.connect(investor4).castVote(1, 1, "POUR - commission plus basse = plus attractif");
            console.log("‚úÖ Investor4 vote POUR (2 votes)");
            results.governance.success++;
            
        } catch (error) {
            console.log("‚ùå Vote Investor4 FAILED:", error.message.split('\n')[0]);
            results.governance.failed++;
        }

        // R√©sultats d√©taill√©s du vote
        console.log("\nüìä R√âSULTATS VOTE D√âTAILL√âS:");
        try {
            const proposal = await governance.getProposal(1);
            const results_vote = await governance.getProposalResults(1);
            
            console.log(`Votes POUR: ${proposal.forVotes} (Investor2: 8 + Investor4: 2 = 10)`);
            console.log(`Votes CONTRE: ${proposal.againstVotes} (Investor3: 10)`);
            console.log(`Abstentions: ${proposal.abstainVotes}`);
            console.log(`Participation: ${results_vote.participationRate}% (besoin 20%)`);
            console.log(`Support: ${results_vote.supportRate}% (besoin 60%)`);
            
            if (results_vote.participationRate.gte(20) && results_vote.supportRate.gte(60)) {
                console.log("‚úÖ Proposition devrait PASSER (quorum + majorit√© atteints)");
            } else {
                console.log("‚ùå Proposition devrait √âCHOUER (crit√®res non atteints)");
            }
            
            results.governance.success++;
            
        } catch (error) {
            console.log("‚ùå R√©sultats vote FAILED:", error.message.split('\n')[0]);
            results.governance.failed++;
        }

        // ===== PHASE 9: ROUND 3 (OPTIONNEL) =====
        console.log("\n" + "=".repeat(60));
        console.log("üöÄ PHASE 9 - ROUND 3 (PRIX √âLEV√â)");
        console.log("=".repeat(60));

        try {
            await campaign.connect(founder).startNewRound(
                ethers.utils.parseEther("100"), // 100 ETH target
                ethers.utils.parseEther("10"),  // 10 ETH par NFT (prix tr√®s √©lev√©)
                15 * 24 * 60 * 60 // 15 jours
            );
            console.log("‚úÖ Round 3 d√©marr√©: 10 ETH/NFT (prix premium)");
            
            // Petit investissement Round 3
            await campaign.connect(investor1).buyShares(1, { value: ethers.utils.parseEther("10") });
            console.log("‚úÖ Investor1: 1 NFT Round 3 pour 10 ETH");
            
            results.rounds.success += 2;
            
        } catch (error) {
            console.log("‚ùå Round 3 FAILED:", error.message.split('\n')[0]);
            results.rounds.failed++;
        }

    } catch (globalError) {
        console.log("‚ùå ERREUR GLOBALE:", globalError.message);
        results.bugs.push({ severity: "CRITICAL", error: "Erreur globale: " + globalError.message });
    }

    // ===== RAPPORT FINAL EXHAUSTIF =====
    console.log("\n" + "=".repeat(80));
    console.log("üìä RAPPORT FINAL EXHAUSTIF - ANALYSE COMPL√àTE");
    console.log("=".repeat(80));

    console.log(`\nüèóÔ∏è D√âPLOIEMENTS: ${results.deployments.success} succ√®s, ${results.deployments.failed} √©checs`);
    console.log(`üöÄ ROUNDS: ${results.rounds.success} succ√®s, ${results.rounds.failed} √©checs`);
    console.log(`üîÑ REMBOURSEMENTS: ${results.refunds.success} succ√®s, ${results.refunds.failed} √©checs`);
    console.log(`üó≥Ô∏è GOUVERNANCE: ${results.governance.success} succ√®s, ${results.governance.failed} √©checs`);
    console.log(`üèõÔ∏è DAO: ${results.dao.success} succ√®s, ${results.dao.failed} √©checs`);

    console.log("\nüí∞ CO√õTS DE D√âPLOIEMENT:");
    results.costs.deploymentCosts.forEach((cost, i) => {
        console.log(`${i+1}. ${cost.contract} (${cost.payer || 'Unknown'}): ${cost.cost} ETH (${cost.gasUsed} gas)`);
    });

    console.log("\nüí∏ CO√õTS TRANSACTIONS:");
    results.costs.transactionCosts.forEach((cost, i) => {
        console.log(`${i+1}. ${cost.action} (${cost.payer}): ${cost.cost} ETH (${cost.gasUsed} gas)`);
    });

    console.log("\nüö® BUGS D√âTECT√âS:");
    results.bugs.forEach((bug, i) => {
        if (typeof bug === 'string') {
            console.log(`${i+1}. ${bug}`);
        } else {
            console.log(`${i+1}. [${bug.severity}] ${bug.error}`);
        }
    });

    console.log("\n‚ö†Ô∏è AVERTISSEMENTS:");
    results.warnings.forEach((warning, i) => {
        console.log(`${i+1}. ${warning}`);
    });

    const totalOperations = results.deployments.success + results.rounds.success + results.refunds.success + results.governance.success + results.dao.success;
    const totalFailures = results.deployments.failed + results.rounds.failed + results.refunds.failed + results.governance.failed + results.dao.failed;
    
    console.log(`\nüìà TAUX DE R√âUSSITE GLOBAL: ${((totalOperations / (totalOperations + totalFailures)) * 100).toFixed(1)}%`);
    console.log(`üìä ${totalOperations} op√©rations r√©ussies, ${totalFailures} √©checs`);

    if (results.bugs.length === 0 && totalFailures === 0) {
        console.log("\nüéâ SYST√àME 100% VALID√â - TOUS SC√âNARIOS PASS√âS!");
        console.log("üöÄ PR√äT POUR PRODUCTION AVEC CONFIANCE TOTALE!");
    } else if (results.bugs.length === 0) {
        console.log("\n‚úÖ AUCUN BUG CRITIQUE D√âTECT√â");
        console.log("‚ö†Ô∏è Quelques √©checs mineurs √† investiguer");
    } else {
        console.log(`\n‚ùå ${results.bugs.length} bugs √† corriger avant production`);
        console.log("üîß SYST√àME PAS ENCORE PR√äT");
    }

    console.log("\nüîç QUI PAYE QUOI:");
    console.log("‚Ä¢ Campaign ‚Üí Deployer paye");
    console.log("‚Ä¢ CampaignDAO ‚Üí Founder paye");
    console.log("‚Ä¢ CampaignGovernance ‚Üí Deployer paye");
    console.log("‚Ä¢ Cr√©er proposition ‚Üí Founder paye");
    console.log("‚Ä¢ Voter ‚Üí Chaque investisseur paye son vote");
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error("üí• ERREUR FATALE:", error.message);
        process.exit(1);
    });