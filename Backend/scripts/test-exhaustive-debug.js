const { ethers } = require("hardhat");

async function main() {
    console.log("üî¨ TEST EXHAUSTIF & DEBUG - √âCOSYST√àME LIVAR");
    console.log("=" .repeat(60));
    console.log("üìã AUCUN ARR√äT - ON DOCUMENTE TOUT, M√äME LES √âCHECS");
    console.log("=" .repeat(60));
    
    let results = {
        deployments: [],
        investments: [],
        refunds: [],
        finalization: [],
        dao: [],
        governance: [],
        bugs: [],
        warnings: []
    };

    try {
        // R√©cup√©rer signers
        let [deployer, founder, investor1, investor2, investor3, treasury] = await ethers.getSigners();
        
        console.log("\nüë• PARTICIPANTS:");
        console.log("üèóÔ∏è Deployeur:", deployer.address);
        console.log("üëë Founder:", founder.address);
        console.log("üí∞ Investor1:", investor1.address);
        console.log("üí∞ Investor2:", investor2.address);
        console.log("üí∞ Investor3:", investor3.address);
        console.log("üè¶ Treasury:", treasury.address);

        // ===== PHASE 1: D√âPLOIEMENTS =====
        console.log("\n" + "=".repeat(50));
        console.log("üèóÔ∏è PHASE 1 - D√âPLOIEMENTS");
        console.log("=".repeat(50));

        let campaign, dao, governance, liveManager;

        try {
            const Campaign = await ethers.getContractFactory("Campaign");
            campaign = await Campaign.deploy(
                founder.address,
                "Livar Exhaustive Test",
                "LET",
                ethers.utils.parseEther("20"), // 20 ETH target
                ethers.utils.parseEther("2"),  // 2 ETH par NFT
                Math.floor(Date.now() / 1000) + (24 * 60 * 60), // 24h
                treasury.address,
                500,
                treasury.address,
                "ipfs://exhaustive-test",
                deployer.address,
                deployer.address
            );
            await campaign.deployed();
            console.log("‚úÖ Campaign d√©ploy√©:", campaign.address);
            results.deployments.push({ contract: "Campaign", status: "SUCCESS", address: campaign.address });
        } catch (error) {
            console.log("‚ùå Campaign FAILED:", error.message.split('\n')[0]);
            results.deployments.push({ contract: "Campaign", status: "FAILED", error: error.message });
        }

        try {
            const LiveSessionManager = await ethers.getContractFactory("LiveSessionManager");
            liveManager = await LiveSessionManager.deploy();
            await liveManager.deployed();
            console.log("‚úÖ LiveSessionManager d√©ploy√©:", liveManager.address);
            results.deployments.push({ contract: "LiveSessionManager", status: "SUCCESS", address: liveManager.address });
        } catch (error) {
            console.log("‚ùå LiveSessionManager FAILED:", error.message.split('\n')[0]);
            results.deployments.push({ contract: "LiveSessionManager", status: "FAILED", error: error.message });
        }

        try {
            const CampaignDAO = await ethers.getContractFactory("CampaignDAO");
            dao = await CampaignDAO.deploy(campaign.address, liveManager.address, founder.address);
            await dao.deployed();
            console.log("‚úÖ CampaignDAO d√©ploy√©:", dao.address);
            results.deployments.push({ contract: "CampaignDAO", status: "SUCCESS", address: dao.address });
        } catch (error) {
            console.log("‚ùå CampaignDAO FAILED:", error.message.split('\n')[0]);
            results.deployments.push({ contract: "CampaignDAO", status: "FAILED", error: error.message });
        }

        try {
            const CampaignGovernance = await ethers.getContractFactory("CampaignGovernance");
            governance = await CampaignGovernance.deploy(campaign.address, founder.address);
            await governance.deployed();
            console.log("‚úÖ CampaignGovernance d√©ploy√©:", governance.address);
            results.deployments.push({ contract: "CampaignGovernance", status: "SUCCESS", address: governance.address });
        } catch (error) {
            console.log("‚ùå CampaignGovernance FAILED:", error.message.split('\n')[0]);
            results.deployments.push({ contract: "CampaignGovernance", status: "FAILED", error: error.message });
        }

        // Connexions
        console.log("\nüîó CONNEXIONS DES CONTRATS:");
        
        try {
            if (campaign && dao) {
                await campaign.connect(founder).setDAOContract(dao.address);
                console.log("‚úÖ DAO connect√© au Campaign");
                results.deployments.push({ contract: "DAO Connection", status: "SUCCESS" });
            }
        } catch (error) {
            console.log("‚ùå DAO Connection FAILED:", error.message.split('\n')[0]);
            results.deployments.push({ contract: "DAO Connection", status: "FAILED", error: error.message });
        }

        try {
            if (campaign && governance) {
                await campaign.connect(founder).setGovernanceContract(governance.address);
                console.log("‚úÖ Governance connect√© au Campaign");
                results.deployments.push({ contract: "Governance Connection", status: "SUCCESS" });
            }
        } catch (error) {
            console.log("‚ùå Governance Connection FAILED:", error.message.split('\n')[0]);
            results.deployments.push({ contract: "Governance Connection", status: "FAILED", error: error.message });
        }

        // ===== PHASE 2: INVESTISSEMENTS =====
        console.log("\n" + "=".repeat(50));
        console.log("üí∞ PHASE 2 - INVESTISSEMENTS");
        console.log("=".repeat(50));

        // Investment 1
        try {
            await campaign.connect(investor1).buyShares(3, { value: ethers.utils.parseEther("6") });
            console.log("‚úÖ Investor1: 3 NFTs pour 6 ETH");
            results.investments.push({ investor: "investor1", nfts: 3, amount: "6 ETH", status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå Investor1 investment FAILED:", error.message.split('\n')[0]);
            results.investments.push({ investor: "investor1", status: "FAILED", error: error.message });
        }

        // Investment 2
        try {
            await campaign.connect(investor2).buyShares(2, { value: ethers.utils.parseEther("4") });
            console.log("‚úÖ Investor2: 2 NFTs pour 4 ETH");
            results.investments.push({ investor: "investor2", nfts: 2, amount: "4 ETH", status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå Investor2 investment FAILED:", error.message.split('\n')[0]);
            results.investments.push({ investor: "investor2", status: "FAILED", error: error.message });
        }

        // Investment 3 - Atteindre l'objectif (17 ETH nets)
        try {
            await campaign.connect(investor3).buyShares(5, { value: ethers.utils.parseEther("10") });
            console.log("‚úÖ Investor3: 5 NFTs pour 10 ETH (pour atteindre objectif)");
            results.investments.push({ investor: "investor3", nfts: 5, amount: "10 ETH", status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå Investor3 investment FAILED:", error.message.split('\n')[0]);
            results.investments.push({ investor: "investor3", status: "FAILED", error: error.message });
        }

        // √âtat apr√®s investissements
        try {
            const roundInfo = await campaign.getCurrentRound();
            console.log(`üìä √âtat Round 1: ${ethers.utils.formatEther(roundInfo.fundsRaised)} ETH lev√©s, ${roundInfo.sharesSold} NFTs vendus, finalis√©: ${roundInfo.isFinalized}`);
            results.investments.push({ 
                type: "ROUND_STATE", 
                fundsRaised: ethers.utils.formatEther(roundInfo.fundsRaised),
                nftsSold: roundInfo.sharesSold.toString(),
                finalized: roundInfo.isFinalized,
                status: "SUCCESS"
            });
        } catch (error) {
            console.log("‚ùå Round state check FAILED:", error.message.split('\n')[0]);
            results.investments.push({ type: "ROUND_STATE", status: "FAILED", error: error.message });
        }

        // ===== PHASE 3: TESTS REMBOURSEMENT =====
        console.log("\n" + "=".repeat(50));
        console.log("üîÑ PHASE 3 - TESTS REMBOURSEMENT");
        console.log("=".repeat(50));

        // Test remboursement Round 1 actif
        console.log("\nüß™ TEST 1: Remboursement Round actuel");
        try {
            const [canRefund1, msg1] = await campaign.canRefundToken(1000001);
            console.log(`NFT #1000001: ${canRefund1 ? '‚úÖ' : '‚ùå'} - ${msg1}`);
            results.refunds.push({ 
                test: "Round actuel", 
                tokenId: "1000001", 
                canRefund: canRefund1, 
                message: msg1, 
                status: "SUCCESS" 
            });
        } catch (error) {
            console.log("‚ùå Refund test 1 FAILED:", error.message.split('\n')[0]);
            results.refunds.push({ test: "Round actuel", status: "FAILED", error: error.message });
        }

        // Finaliser Round 1
        console.log("\nüèÅ FINALISATION ROUND 1");
        try {
            await campaign.connect(deployer).finalizeRound();
            console.log("‚úÖ Round 1 finalis√©");
            results.finalization.push({ action: "finalize_round", status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå Round 1 finalization FAILED:", error.message.split('\n')[0]);
            results.finalization.push({ action: "finalize_round", status: "FAILED", error: error.message });
        }

        // V√©rifier phase DAO
        try {
            const daoPhase = await dao.getCurrentPhase();
            console.log(`üèõÔ∏è Phase DAO apr√®s finalisation: ${daoPhase} (1=WAITING_FOR_LIVE)`);
            results.dao.push({ action: "check_phase_after_finalization", phase: daoPhase.toString(), status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå DAO phase check FAILED:", error.message.split('\n')[0]);
            results.dao.push({ action: "check_phase_after_finalization", status: "FAILED", error: error.message });
        }

        // Test remboursement apr√®s finalisation
        console.log("\nüß™ TEST 2: Remboursement apr√®s finalisation Round 1");
        try {
            const [canRefund2, msg2] = await campaign.canRefundToken(1000001);
            console.log(`NFT #1000001: ${canRefund2 ? '‚úÖ' : '‚ùå'} - ${msg2}`);
            results.refunds.push({ 
                test: "Apr√®s finalisation", 
                tokenId: "1000001", 
                canRefund: canRefund2, 
                message: msg2, 
                status: "SUCCESS" 
            });
        } catch (error) {
            console.log("‚ùå Refund test 2 FAILED:", error.message.split('\n')[0]);
            results.refunds.push({ test: "Apr√®s finalisation", status: "FAILED", error: error.message });
        }

        // ===== PHASE 4: ROUND 2 =====
        console.log("\n" + "=".repeat(50));
        console.log("üöÄ PHASE 4 - ROUND 2");
        console.log("=".repeat(50));

        try {
            await campaign.connect(founder).startNewRound(
                ethers.utils.parseEther("30"),
                ethers.utils.parseEther("5"),
                24 * 60 * 60 // 24h
            );
            console.log("‚úÖ Round 2 d√©marr√© (5 ETH/NFT)");
            results.investments.push({ action: "start_round_2", status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå Round 2 start FAILED:", error.message.split('\n')[0]);
            results.investments.push({ action: "start_round_2", status: "FAILED", error: error.message });
        }

        // Investissement Round 2 (nouveau investisseur pour √©viter confusion)
        try {
            await campaign.connect(investor1).buyShares(2, { value: ethers.utils.parseEther("10") });
            console.log("‚úÖ Investor1: 2 NFTs Round 2 pour 10 ETH");
            results.investments.push({ investor: "investor1", nfts: 2, amount: "10 ETH", round: 2, status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå Investor1 Round 2 investment FAILED:", error.message.split('\n')[0]);
            results.investments.push({ investor: "investor1", round: 2, status: "FAILED", error: error.message });
        }

        // üî• TEST CRITIQUE: Remboursement Round 1 pendant Round 2
        console.log("\nüß™ TEST 3 (CRITIQUE): Round 1 pendant Round 2 avec DAO active");
        try {
            const [canRefund3, msg3] = await campaign.canRefundToken(1000001);
            console.log(`NFT #1000001: ${canRefund3 ? '‚úÖ' : '‚ùå'} - ${msg3}`);
            
            if (canRefund3) {
                results.bugs.push({
                    bug: "NFT Round 1 remboursable pendant Round 2 √† cause phase DAO",
                    severity: "CRITICAL",
                    tokenId: "1000001",
                    message: msg3
                });
                console.log("üö® BUG D√âTECT√â: NFT Round 1 ne devrait PAS √™tre remboursable pendant Round 2 !");
            } else {
                console.log("‚úÖ Comportement correct: NFT Round 1 bloqu√© pendant Round 2");
            }
            
            results.refunds.push({ 
                test: "Round 1 pendant Round 2", 
                tokenId: "1000001", 
                canRefund: canRefund3, 
                message: msg3, 
                status: "SUCCESS" 
            });
        } catch (error) {
            console.log("‚ùå Refund test 3 FAILED:", error.message.split('\n')[0]);
            results.refunds.push({ test: "Round 1 pendant Round 2", status: "FAILED", error: error.message });
        }

        // Test remboursement Round 2
        console.log("\nüß™ TEST 4: Remboursement Round 2 actuel");
        try {
            const [canRefund4, msg4] = await campaign.canRefundToken(2000001);
            console.log(`NFT #2000001: ${canRefund4 ? '‚úÖ' : '‚ùå'} - ${msg4}`);
            results.refunds.push({ 
                test: "Round 2 actuel", 
                tokenId: "2000001", 
                canRefund: canRefund4, 
                message: msg4, 
                status: "SUCCESS" 
            });
        } catch (error) {
            console.log("‚ùå Refund test 4 FAILED:", error.message.split('\n')[0]);
            results.refunds.push({ test: "Round 2 actuel", status: "FAILED", error: error.message });
        }

        // ===== PHASE 5: SESSION LIVE DAO =====
        console.log("\n" + "=".repeat(50));
        console.log("üé• PHASE 5 - SESSION LIVE DAO");
        console.log("=".repeat(50));

        // Programmer session live
        const futureTime = Math.floor(Date.now() / 1000) + 3600;
        try {
            await dao.connect(founder).scheduleLiveSession(
                futureTime,
                "https://stream.livar.com/test"
            );
            console.log("‚úÖ Session live programm√©e");
            results.dao.push({ action: "schedule_live", status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå Schedule live FAILED:", error.message.split('\n')[0]);
            results.dao.push({ action: "schedule_live", status: "FAILED", error: error.message });
        }

        // Simuler le temps
        console.log("‚è∞ Simulation: 1h passe...");
        await ethers.provider.send("evm_increaseTime", [3600]);
        await ethers.provider.send("evm_mine");

        // D√©marrer live
        try {
            await dao.connect(founder).startLiveSession();
            console.log("‚úÖ Session live d√©marr√©e");
            results.dao.push({ action: "start_live", status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå Start live FAILED:", error.message.split('\n')[0]);
            results.dao.push({ action: "start_live", status: "FAILED", error: error.message });
        }

        // Simuler dur√©e live
        console.log("‚è∞ Simulation: Live 20 minutes...");
        await ethers.provider.send("evm_increaseTime", [20 * 60]);
        await ethers.provider.send("evm_mine");

        // Terminer live
        try {
            await dao.connect(founder).endLiveSession(15);
            console.log("‚úÖ Session live termin√©e (20 min ‚Üí Valide)");
            results.dao.push({ action: "end_live", duration: "20min", valid: true, status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå End live FAILED:", error.message.split('\n')[0]);
            results.dao.push({ action: "end_live", status: "FAILED", error: error.message });
        }

        // V√©rifier phase √©change
        try {
            const finalPhase = await dao.getCurrentPhase();
            console.log(`üîÑ Phase apr√®s live: ${finalPhase} (4=EXCHANGE_PERIOD)`);
            results.dao.push({ action: "check_exchange_phase", phase: finalPhase.toString(), status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå Exchange phase check FAILED:", error.message.split('\n')[0]);
            results.dao.push({ action: "check_exchange_phase", status: "FAILED", error: error.message });
        }

        // ===== PHASE 6: GOUVERNANCE =====
        console.log("\n" + "=".repeat(50));
        console.log("üó≥Ô∏è PHASE 6 - GOUVERNANCE");
        console.log("=".repeat(50));

        // V√©rifier pouvoirs de vote
        try {
            const power1 = await governance.getVotingPower(investor1.address);
            const power2 = await governance.getVotingPower(investor2.address);
            const power3 = await governance.getVotingPower(investor3.address);
            console.log(`üìä Pouvoirs de vote: Investor1=${power1}, Investor2=${power2}, Investor3=${power3}`);
            results.governance.push({ 
                action: "check_voting_power", 
                investor1: power1.toString(), 
                investor2: power2.toString(),
                investor3: power3.toString(),
                status: "SUCCESS" 
            });
        } catch (error) {
            console.log("‚ùå Voting power check FAILED:", error.message.split('\n')[0]);
            results.governance.push({ action: "check_voting_power", status: "FAILED", error: error.message });
        }

        // Cr√©er proposition
        try {
            await governance.connect(founder).createProposal(
                0, // PARAMETER_CHANGE
                "R√©duire commission 15% ‚Üí 10%",
                "Test de gouvernance exhaustif",
                ethers.utils.defaultAbiCoder.encode(["uint256"], [10]),
                30, // 30% quorum
                51  // 51% majorit√©
            );
            console.log("‚úÖ Proposition gouvernance cr√©√©e");
            results.governance.push({ action: "create_proposal", status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå Create proposal FAILED:", error.message.split('\n')[0]);
            results.governance.push({ action: "create_proposal", status: "FAILED", error: error.message });
        }

        // Votes
        try {
            await governance.connect(investor1).castVote(1, 1, "Vote pour");
            console.log("‚úÖ Investor1 vote POUR");
            results.governance.push({ action: "vote_investor1", vote: "FOR", status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå Investor1 vote FAILED:", error.message.split('\n')[0]);
            results.governance.push({ action: "vote_investor1", status: "FAILED", error: error.message });
        }

        try {
            await governance.connect(investor2).castVote(1, 0, "Vote contre");
            console.log("‚úÖ Investor2 vote CONTRE");
            results.governance.push({ action: "vote_investor2", vote: "AGAINST", status: "SUCCESS" });
        } catch (error) {
            console.log("‚ùå Investor2 vote FAILED:", error.message.split('\n')[0]);
            results.governance.push({ action: "vote_investor2", status: "FAILED", error: error.message });
        }

        // R√©sultats vote
        try {
            const voteResults = await governance.getProposalResults(1);
            console.log(`üìä R√©sultats: Participation=${voteResults.participationRate}%, Support=${voteResults.supportRate}%`);
            results.governance.push({ 
                action: "vote_results", 
                participation: voteResults.participationRate.toString(),
                support: voteResults.supportRate.toString(),
                status: "SUCCESS" 
            });
        } catch (error) {
            console.log("‚ùå Vote results FAILED:", error.message.split('\n')[0]);
            results.governance.push({ action: "vote_results", status: "FAILED", error: error.message });
        }

    } catch (globalError) {
        console.log("‚ùå GLOBAL ERROR:", globalError.message);
        results.bugs.push({ bug: "Global execution error", severity: "CRITICAL", error: globalError.message });
    }

    // ===== RAPPORT FINAL =====
    console.log("\n" + "=".repeat(60));
    console.log("üìä RAPPORT FINAL - ANALYSE EXHAUSTIVE");
    console.log("=".repeat(60));

    console.log("\nüèóÔ∏è D√âPLOIEMENTS:", results.deployments.filter(d => d.status === "SUCCESS").length, "succ√®s,", results.deployments.filter(d => d.status === "FAILED").length, "√©checs");
    console.log("üí∞ INVESTISSEMENTS:", results.investments.filter(i => i.status === "SUCCESS").length, "succ√®s,", results.investments.filter(i => i.status === "FAILED").length, "√©checs");
    console.log("üîÑ REMBOURSEMENTS:", results.refunds.filter(r => r.status === "SUCCESS").length, "succ√®s,", results.refunds.filter(r => r.status === "FAILED").length, "√©checs");
    console.log("üó≥Ô∏è GOUVERNANCE:", results.governance.filter(g => g.status === "SUCCESS").length, "succ√®s,", results.governance.filter(g => g.status === "FAILED").length, "√©checs");
    console.log("üèõÔ∏è DAO:", results.dao.filter(d => d.status === "SUCCESS").length, "succ√®s,", results.dao.filter(d => d.status === "FAILED").length, "√©checs");

    console.log("\nüö® BUGS D√âTECT√âS:");
    results.bugs.forEach((bug, i) => {
        console.log(`${i+1}. [${bug.severity}] ${bug.bug}`);
        if (bug.error) console.log(`   Erreur: ${bug.error.split('\n')[0]}`);
    });

    if (results.bugs.length === 0) {
        console.log("‚úÖ Aucun bug critique d√©tect√©!");
    }

    console.log("\nüéØ PROBL√àMES √Ä CORRIGER:");
    if (results.bugs.some(b => b.bug.includes("Round 1 pendant Round 2"))) {
        console.log("1. üî¥ CRITIQUE: NFT Round 1 remboursable pendant Round 2 (logique phase DAO incorrecte)");
    }
    
    // Compter les √©checs
    const totalTests = results.deployments.length + results.investments.length + results.refunds.length + results.governance.length + results.dao.length;
    const totalFailures = 
        results.deployments.filter(d => d.status === "FAILED").length +
        results.investments.filter(i => i.status === "FAILED").length +
        results.refunds.filter(r => r.status === "FAILED").length +
        results.governance.filter(g => g.status === "FAILED").length +
        results.dao.filter(d => d.status === "FAILED").length;

    console.log(`\nüìà TAUX DE R√âUSSITE: ${((totalTests - totalFailures) / totalTests * 100).toFixed(1)}%`);
    
    if (totalFailures === 0 && results.bugs.length === 0) {
        console.log("üéâ SYST√àME 100% FONCTIONNEL - PR√äT POUR PRODUCTION!");
    } else {
        console.log(`‚ö†Ô∏è ${totalFailures} √©checs et ${results.bugs.length} bugs √† corriger avant production`);
    }
}

main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error("üí• ERREUR FATALE:", error.message);
        process.exit(1);
    });