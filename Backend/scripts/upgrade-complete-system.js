const { ethers, upgrades } = require("hardhat");

async function main() {
    console.log("üöÄ === UPGRADE SYST√àME COMPLET LIVAR ===");
    console.log("=" .repeat(70));

    // Configuration - BONNES ADRESSES DU CONTRAT ACTUEL
    const PROXY_ADDRESS = "0x89Eba0c82c1f16433473A9A06690BfaAC2c7a1b4";
    const CURRENT_KEEPER = "0x7BA165d19De799DA8070D3c1C061933551726D1E"; // ANCIEN KEEPER UPGRAD√â
    const LIVE_SESSION_MANAGER = "0x12B9A0B4ffa86Be855a0F2604916F82C53d98BD0"; // BON
    const NETWORK = process.env.HARDHAT_NETWORK || "sepoliaBase";
    
    // üö® S√âCURIT√â CRITIQUE: V√©rifier que le proxy n'est PAS adresse zero
    if (PROXY_ADDRESS === ethers.constants.AddressZero || PROXY_ADDRESS === "0x0000000000000000000000000000000000000000") {
        throw new Error("üö® ERREUR CRITIQUE: PROXY_ADDRESS est adresse ZERO!");
    }
    
    console.log(`üåê Network: ${NETWORK}`);
    console.log(`üìç Proxy address: ${PROXY_ADDRESS}`);

    let deploymentAddresses = {
        proxy: PROXY_ADDRESS,
        liveSessionManager: null,
        campaignKeeper: null,
        newCampaigns: []
    };

    try {
        // === √âTAPE 1: D√âPLOYER NOUVEAUX CONTRATS ===
        console.log("\n" + "=".repeat(50));
        console.log("üÜï √âTAPE 1: D√âPLOYER NOUVEAUX CONTRATS");
        console.log("=".repeat(50));

        // D√©ployer LiveSessionManager
        console.log("\nüì± D√©ploiement LiveSessionManager...");
        const LiveSessionManager = await ethers.getContractFactory("LiveSessionManager");
        const liveManager = await LiveSessionManager.deploy();
        await liveManager.deployed();
        
        // S√âCURIT√â: V√©rifier que l'adresse n'est PAS zero
        if (liveManager.address === ethers.constants.AddressZero || liveManager.address === "0x0000000000000000000000000000000000000000") {
            throw new Error("üö® ERREUR CRITIQUE: LiveSessionManager d√©ploy√© √† adresse ZERO!");
        }
        
        deploymentAddresses.liveSessionManager = liveManager.address;
        console.log(`‚úÖ LiveSessionManager d√©ploy√©: ${liveManager.address}`);

        // Utiliser l'ANCIEN KEEPER qui est d√©j√† UPGRAD√â
        console.log("\nü§ñ Utilisation CampaignKeeper EXISTANT (d√©j√† upgrad√©)...");
        const DivarProxy = await ethers.getContractFactory("DivarProxy");
        const currentProxy = DivarProxy.attach(PROXY_ADDRESS);
        
        let keeperAddress = CURRENT_KEEPER;  // UTILISER L'ANCIEN QUI EST UPGRAD√â
        console.log(`üìç CampaignKeeper √† utiliser: ${keeperAddress}`);
        
        // V√©rifier que c'est bien celui dans le proxy
        try {
            const proxyKeeper = await currentProxy.campaignKeeper();
            if (proxyKeeper.toLowerCase() !== keeperAddress.toLowerCase()) {
                console.log(`‚ö†Ô∏è Proxy pointe vers: ${proxyKeeper}`);
                console.log(`‚ö†Ô∏è On veut utiliser: ${keeperAddress}`);
                console.log("üîÑ Mise √† jour n√©cessaire...");
                deploymentAddresses.campaignKeeper = keeperAddress;
            } else {
                console.log("‚úÖ CampaignKeeper correct dans le proxy");
            }
        } catch (e) {
            console.log("‚ùå Impossible de v√©rifier le CampaignKeeper du proxy");
            throw new Error("Proxy inaccessible");
        }

        // === √âTAPE 2: UPGRADE DU PROXY ===
        console.log("\n" + "=".repeat(50));
        console.log("‚¨ÜÔ∏è √âTAPE 2: UPGRADE DU PROXY");
        console.log("=".repeat(50));

        let upgradedProxy;
        try {
            console.log("‚è≥ Upgrade du proxy DivarProxy...");
            upgradedProxy = await upgrades.upgradeProxy(PROXY_ADDRESS, DivarProxy);
            console.log("‚úÖ Proxy upgrad√© avec succ√®s !");
        } catch (upgradeError) {
            console.log("‚ÑπÔ∏è Proxy d√©j√† √† jour:", upgradeError.message.split('\n')[0]);
            upgradedProxy = currentProxy;
        }

        // Mettre √† jour le CampaignKeeper si n√©cessaire
        if (deploymentAddresses.campaignKeeper) {
            console.log("üîÑ Mise √† jour du CampaignKeeper dans le proxy...");
            const updateKeeperTx = await upgradedProxy.setCampaignKeeper(keeperAddress);
            await updateKeeperTx.wait();
            console.log("‚úÖ CampaignKeeper mis √† jour dans le proxy");
        }

        // === √âTAPE 3: MISE √Ä JOUR CAMPAIGN BYTECODE ===
        console.log("\n" + "=".repeat(50));
        console.log("üì¶ √âTAPE 3: MISE √Ä JOUR CAMPAIGN BYTECODE");
        console.log("=".repeat(50));

        const Campaign = await ethers.getContractFactory("Campaign");
        const campaignBytecode = Campaign.bytecode;
        
        console.log("‚è≥ Mise √† jour du bytecode Campaign...");
        const setBytecodeeTx = await upgradedProxy.setCampaignBytecode(campaignBytecode);
        const receipt = await setBytecodeeTx.wait();
        
        console.log(`‚úÖ Campaign bytecode mis √† jour ! Gas: ${receipt.gasUsed}`);
        console.log("üéâ Nouveaux correctifs inclus:");
        console.log("  ‚Ä¢ Bug fix: NFT remboursables apr√®s live sessions");
        console.log("  ‚Ä¢ Support multi-rounds complet");
        console.log("  ‚Ä¢ Syst√®me de gouvernance int√©gr√©");

        // === √âTAPE 4: TEST FONCTIONNALIT√âS NOUVELLES ===
        console.log("\n" + "=".repeat(50));
        console.log("üß™ √âTAPE 4: TESTS FONCTIONNALIT√âS");
        console.log("=".repeat(50));

        // Test 1: Fonctions de base
        console.log("\nüîç Test 1: Fonctions proxy de base");
        try {
            const campaigns = await upgradedProxy.getAllCampaigns();
            console.log(`‚úÖ getAllCampaigns: ${campaigns.length} campagnes`);
            
            const fee = await upgradedProxy.getCampaignCreationFeeETH();
            console.log(`‚úÖ Fee cr√©ation: ${ethers.utils.formatEther(fee)} ETH`);
            
            const version = await upgradedProxy.getVersion();
            console.log(`‚úÖ Version proxy: ${version}`);
        } catch (e) {
            console.log("‚ùå Test fonctions de base FAILED:", e.message);
        }

        // Test 2: CampaignKeeper avec nouvelles fonctions
        console.log("\nüîç Test 2: CampaignKeeper nouvelles fonctions");
        try {
            const CampaignKeeper = await ethers.getContractFactory("CampaignKeeper");
            const keeper = CampaignKeeper.attach(keeperAddress);
            
            // Test fonction DAO (m√™me si vide)
            const testDAO = await keeper.getDAOForCampaign(ethers.constants.AddressZero);
            console.log("‚úÖ getDAOForCampaign fonctionne");
            
            const isActive = await keeper.isDAOActive(ethers.constants.AddressZero);
            console.log("‚úÖ isDAOActive fonctionne");
            
            console.log("‚úÖ CampaignKeeper pr√™t pour les DAOs");
        } catch (e) {
            console.log("‚ùå Test CampaignKeeper FAILED:", e.message);
        }

        // Test 3: LiveSessionManager
        console.log("\nüîç Test 3: LiveSessionManager");
        try {
            // Test simple - juste v√©rifier qu'il est d√©ploy√©
            const code = await ethers.provider.getCode(liveManager.address);
            if (code !== "0x") {
                console.log("‚úÖ LiveSessionManager d√©ploy√© et fonctionnel");
            }
        } catch (e) {
            console.log("‚ùå Test LiveSessionManager FAILED:", e.message);
        }

        // === √âTAPE 5: TEST CR√âATION CAMPAGNE (SIMULATION) ===
        console.log("\n" + "=".repeat(50));
        console.log("üéØ √âTAPE 5: SIMULATION CR√âATION CAMPAGNE V2");
        console.log("=".repeat(50));

        try {
            const [deployer] = await ethers.getSigners();
            const fee = await upgradedProxy.getCampaignCreationFeeETH();
            
            console.log("üìã Param√®tres test:");
            console.log(`  ‚Ä¢ Creator: ${deployer.address}`);
            console.log(`  ‚Ä¢ Fee requise: ${ethers.utils.formatEther(fee)} ETH`);
            console.log(`  ‚Ä¢ Bytecode pr√™t: ${campaignBytecode.length > 0 ? '‚úÖ' : '‚ùå'}`);
            
            // Si testnet et qu'on a des fonds, on peut cr√©er une vraie campagne test
            const balance = await ethers.provider.getBalance(deployer.address);
            if (balance.gt(fee.mul(2)) && NETWORK === "sepoliaBase") {
                console.log("\nüöÄ Cr√©ation campagne de test r√©elle...");
                
                const createTx = await upgradedProxy.createCampaign(
                    "Test Campaign V2 - DAO Ready", // name
                    "TCV2", // symbol
                    ethers.utils.parseEther("10"), // target 10 ETH
                    ethers.utils.parseEther("1"), // price 1 ETH per NFT
                    Math.floor(Date.now() / 1000) + (30 * 24 * 60 * 60), // 30 jours
                    "test", // category
                    "ipfs://test-metadata-v2", // metadata
                    500, // 5% royalty
                    "https://test-logo.com/logo.png", // logo
                    { value: fee }
                );
                
                const createReceipt = await createTx.wait();
                console.log(`‚úÖ Campagne test cr√©√©e ! Gas: ${createReceipt.gasUsed}`);
                
                // R√©cup√©rer l'adresse de la nouvelle campagne
                const campaigns = await upgradedProxy.getAllCampaigns();
                const newCampaign = campaigns[campaigns.length - 1];
                
                // S√âCURIT√â: V√©rifier que la campagne n'est PAS √† adresse zero
                if (newCampaign === ethers.constants.AddressZero || newCampaign === "0x0000000000000000000000000000000000000000") {
                    throw new Error("üö® ERREUR CRITIQUE: Campagne cr√©√©e √† adresse ZERO!");
                }
                
                deploymentAddresses.newCampaigns.push(newCampaign);
                console.log(`üéØ Nouvelle campagne: ${newCampaign}`);
                
                // Test des nouvelles fonctions de la campagne
                const CampaignContract = await ethers.getContractFactory("Campaign");
                const campaignInstance = CampaignContract.attach(newCampaign);
                
                try {
                    const roundInfo = await campaignInstance.getCurrentRound();
                    console.log("‚úÖ Campaign V2 fonctionne !");
                    console.log(`  ‚Ä¢ Round: ${roundInfo.roundNumber}`);
                    console.log(`  ‚Ä¢ Prix: ${ethers.utils.formatEther(roundInfo.sharePrice)} ETH`);
                    console.log(`  ‚Ä¢ Target: ${ethers.utils.formatEther(roundInfo.targetAmount)} ETH`);
                    
                    // Test fonction nouvelles
                    const [canRefund, msg] = await campaignInstance.canRefundToken(1000001);
                    console.log("‚úÖ Nouvelles fonctions remboursement OK");
                    
                } catch (e) {
                    console.log("‚ö†Ô∏è Campaign V2 partiellement fonctionnelle:", e.message.split('\n')[0]);
                }
                
            } else {
                console.log("‚ÑπÔ∏è Pas assez de fonds pour test r√©el, simulation OK");
            }
            
        } catch (e) {
            console.log("‚ùå Test cr√©ation campagne FAILED:", e.message);
        }

        // === R√âSUM√â FINAL ===
        console.log("\n" + "=".repeat(70));
        console.log("üìä R√âSUM√â FINAL - UPGRADE SYST√àME COMPLET");
        console.log("=".repeat(70));

        console.log("\n‚úÖ CONTRATS D√âPLOY√âS/MIS √Ä JOUR:");
        console.log(`üìç DivarProxy: ${deploymentAddresses.proxy} (upgrad√©)`);
        console.log(`üì± LiveSessionManager: ${deploymentAddresses.liveSessionManager}`);
        console.log(`ü§ñ CampaignKeeper: ${keeperAddress} ${deploymentAddresses.campaignKeeper ? '(nouveau)' : '(existant)'}`);
        console.log(`üì¶ Campaign Bytecode: Mis √† jour avec V2`);

        console.log("\nüÜï NOUVELLES FONCTIONNALIT√âS DISPONIBLES:");
        console.log("‚Ä¢ Syst√®me DAO avec sessions live obligatoires");
        console.log("‚Ä¢ Remboursements NFT pendant p√©riode d'√©change"); 
        console.log("‚Ä¢ Gouvernance avec votes pond√©r√©s NFT");
        console.log("‚Ä¢ Multi-rounds avec r√®gles correctes");
        console.log("‚Ä¢ Automation Chainlink pour DAOs");

        console.log("\nüîÑ COMPATIBILIT√â:");
        console.log("‚Ä¢ Campagnes EXISTANTES: Inchang√©es, fonctionnent normalement");
        console.log("‚Ä¢ NOUVELLES campagnes: Utilisent automatiquement V2");
        console.log("‚Ä¢ Chainlink Keeper: Compatible avec nouvelles fonctions DAO");

        if (deploymentAddresses.newCampaigns.length > 0) {
            console.log("\nüéØ CAMPAGNES TEST CR√â√âES:");
            deploymentAddresses.newCampaigns.forEach((addr, i) => {
                console.log(`${i+1}. ${addr}`);
            });
        }

        console.log("\nüöÄ SYST√àME PR√äT POUR PRODUCTION !");
        console.log("Tu peux maintenant cr√©er des campagnes avec toutes les nouvelles fonctionnalit√©s !");

        // Sauvegarder les adresses pour r√©f√©rence
        const deploymentInfo = {
            network: NETWORK,
            timestamp: new Date().toISOString(),
            addresses: deploymentAddresses,
            version: "2.0.0"
        };

        console.log("\nüìÑ Sauvegarde des adresses...");
        const fs = require('fs');
        fs.writeFileSync(
            'upgrade-deployment.json', 
            JSON.stringify(deploymentInfo, null, 2)
        );
        console.log("‚úÖ Adresses sauvegard√©es dans upgrade-deployment.json");

    } catch (error) {
        console.error("\n‚ùå ERREUR DURING UPGRADE:");
        console.error("Message:", error.message);
        
        console.log("\nüîß V√âRIFICATIONS:");
        console.log("1. Private key a les droits owner sur le proxy");
        console.log("2. R√©seau correct dans .env");
        console.log("3. Fonds suffisants pour les transactions");
        console.log("4. Proxy address correct");
        
        process.exit(1);
    }
}

main()
    .then(() => {
        console.log("\nüéâ UPGRADE SYST√àME COMPLET TERMIN√â !");
        process.exit(0);
    })
    .catch((error) => {
        console.error("\nüí• FATAL ERROR:", error);
        process.exit(1);
    });